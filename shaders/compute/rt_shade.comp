#version 460

#include "common.glsl"

layout (local_size_x = 16, local_size_y = 16) in;

layout(rgba16f,set = 0, binding = 0) uniform image2D image;

layout(std430, set = 0, binding = 1) buffer IntersectOut
{
    IntersectResult results[];
} intersection_buffer;

layout( push_constant ) uniform PushConstants
{
    mat4 camera_matrix;
    ivec2 render_extent;
} push_constants;

// Hashing taken from https://www.shadertoy.com/view/NtjyWw for now
const uint k = 1103515245U;  // GLIB C

vec3 uhash3( uvec3 x )         // iq version
{
    x = ((x>>8U)^x.yzx)*k;
    x = ((x>>8U)^x.yzx)*k;
    x = ((x>>8U)^x.yzx)*k;

    return vec3(x)/float(0xffffffffU);
}

vec3 hash( vec3 f )
{
    return uhash3( floatBitsToUint(f) );
}

void main()
{
    uint index = int(gl_GlobalInvocationID.x) + int(gl_GlobalInvocationID.y) * push_constants.render_extent.x;

    if (int(gl_GlobalInvocationID.x) >= push_constants.render_extent.x || int(gl_GlobalInvocationID.y) >= push_constants.render_extent.y)
    {
        return;
    }

    IntersectResult result = intersection_buffer.results[index];

    if (result.incoming_direction_and_hit_distance.a != FLT_MAX)
    {
       imageStore(image, ivec2(gl_GlobalInvocationID), vec4(vec3(result.normal.rgb) * 0.5 + vec3(0.5f), 1.0f));
    }
    else
    {
        imageStore(image, ivec2(gl_GlobalInvocationID), vec4(0.0f));
    }
}
