#version 460

#include "common.comph"

layout (local_size_x = 16, local_size_y = 16) in;

layout(rgba16f,set = 0, binding = 0) uniform image2D image;

layout(std430, set = 0, binding = 1) buffer RayGenIn
{
    vec4 data[];
} ray_buffer;

struct ModelHeader
{
	ivec4 index_and_size;
	mat4 inverse_transform;
};

layout(std430, set = 0, binding = 2) buffer ModelIn
{
	ModelHeader headers[8];
    uint data[];
} model_buffer;

layout( push_constant ) uniform PushConstants
{
	mat4 camera_matrix;
} push_constants;

vec3 get_translation_from_matrix(mat4 matrix)
{
	return vec3(matrix[3][0], matrix[3][1], matrix[3][2]);
}

#define FLT_MAX (1.0 / 0.0)
#define EPSILON 0.001f

struct Ray
{
	vec3 direction;
	vec3 position;
};

struct IntersectionState
{
	float t;
	vec3 debug_float;
};

uint from_3d_to_1d(ivec3 in_3d, ivec3 model_size, int model_offset)
{
	return model_offset + (in_3d[0] + in_3d[1] * model_size.x + in_3d[2] * model_size.x * model_size.y);
}

float DDA(inout IntersectionState state, Ray ray, inout ModelHeader header, ivec3 voxel_start_position)
{
    ivec3 voxel_position = voxel_start_position;
	ivec3 size = header.index_and_size.gba;

    // If we start inside a voxel, return
    if (model_buffer.data[from_3d_to_1d(voxel_position, size, header.index_and_size.x)] != 0)
    {
        return 0.0f;
    }

	//state.debug_float.rgb = voxel_position;

    // Voxel Marching
	const ivec3 t_sign = ivec3(sign(ray.direction));
    const vec3 t_delta = abs(vec3(1.0f) / ray.direction);
	vec3 t_max = abs(fract(ray.position) - max(t_sign, vec3(0))) * t_delta;

	uint check = size.x + size.y + size.z;
    while (check > 0)
    {
        // Find the smallest t_max component
        int axis = int(t_max.y < t_max.x);
        if (t_max.z < t_max[axis])
        {
            axis = 2;
        }

        voxel_position[axis] += t_sign[axis];
        t_max[axis] += t_delta[axis];

        // Check bounds
		if (voxel_position[axis] < 0 || voxel_position[axis] >= size[axis])
		{
			return FLT_MAX;
        }

        uint world_index = from_3d_to_1d(voxel_position, size, header.index_and_size.x);
        if (model_buffer.data[world_index] != 0)
        {
            return t_max[axis] - t_delta[axis];
        }
		check -= 1;
    }
	return FLT_MAX;
}


vec4 intersect_aabb(vec3 aabbmin, vec3 aabbmax, Ray ray)
{
	vec3 inv_dir = 1.0f / ray.direction;
	vec3 ti = (aabbmin - ray.position) * inv_dir;
	vec3 ta = (aabbmax - ray.position) * inv_dir;
	vec3 axis_min = min(ti, ta);
	vec3 axis_max = max(ti, ta);
	float tmin = max(axis_min.x, max(axis_min.y, axis_min.z));
	float tmax = min(axis_max.x, min(axis_max.y, axis_max.z));

	if (tmax >= tmin && tmin > 0.0f)
	{
		vec3 normal = -(vec3(1.0f) - step(axis_min, vec3(tmin) - EPSILON)) * sign(ray.direction);

		int axis = int(abs(normal.y) > abs(normal.x));
		if (abs(normal.z) > abs(normal[axis]))
		{
			axis = 2;
		};

		float norm = normal[axis];
		normal = vec3(0.0f);
		normal[axis] = norm;

		return vec4(tmin, normal);
	}
	else
	{
		return vec4(FLT_MAX, tmin, tmax, 0.0f);
	}
}

void intersect(inout IntersectionState state, Ray ray)
{
	for(int i = 0; i < 8; i++)
	{
		int header_index = model_buffer.headers[i].index_and_size.x;
		ivec3 model_size = model_buffer.headers[i].index_and_size.yzw;
		if (header_index != -1)
		{
			vec3 half_size = vec3(model_size) * 0.5f;

			Ray aabb_ray = ray;
			aabb_ray.position = (model_buffer.headers[i].inverse_transform * vec4(aabb_ray.position, 1.0f)).rgb;
			aabb_ray.direction = normalize(model_buffer.headers[i].inverse_transform * vec4(aabb_ray.direction, 0.0f)).rgb;

			// If not inside the AABB
			if (aabb_ray.position != clamp(aabb_ray.position, -half_size, half_size))
			{
				vec4 t_normal = intersect_aabb(-half_size, half_size, aabb_ray);

				if (t_normal.x < state.t)
				{
					vec3 hit_pos = ray.position + ray.direction * (t_normal.r - EPSILON);
					vec3 in_volume_position = (model_buffer.headers[i].inverse_transform * vec4(hit_pos, 1.0f)).xyz + half_size;
					ivec3 voxel_position = ivec3(floor(in_volume_position));

					Ray dda_ray;
					dda_ray.position = clamp(in_volume_position, vec3(EPSILON), model_size - vec3(EPSILON));;
					dda_ray.direction = aabb_ray.direction;

					voxel_position = clamp(voxel_position, ivec3(0), ivec3(model_size) - ivec3(1));

					float t = DDA(state, dda_ray, model_buffer.headers[i], voxel_position);
					t_normal.x += t;

					if (t_normal.x < state.t)
					{
						state.t = min(state.t, t_normal.x);
					}

					state.debug_float = vec3(t * 0.0001f);
				}
			}
		}
	}
}

void main()
{
    ivec2 texelCoord = ivec2(gl_GlobalInvocationID.xy);
	ivec2 size = imageSize(image);
    uint index = texelCoord.x + texelCoord.y * size.x;

	Ray new_ray;
	new_ray.position = get_translation_from_matrix(push_constants.camera_matrix);
	new_ray.direction = ray_buffer.data[index].rgb;

	IntersectionState state;
	state.t = FLT_MAX;
	intersect(state, new_ray);

	if (state.t != FLT_MAX)
	{
		float max_depth_length = 512.0f;//max(model_buffer.size.x, max(model_buffer.size.y, model_buffer.size.z)) + 256.0f;
		imageStore(image, texelCoord, vec4(state.debug_float, 1.0f));
	}
	else
	{
    	imageStore(image, texelCoord, ray_buffer.data[index] * 0.5f + vec4(0.5f));
	}
}
