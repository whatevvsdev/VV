#version 460

layout (local_size_x = 16, local_size_y = 16) in;

layout(rgba16f,set = 0, binding = 0) uniform image2D image;

layout(std430, set = 0, binding = 1) buffer RayGenIn
{
    vec4 data[];
} ray_buffer;

layout( push_constant ) uniform PushConstants
{
	mat4 camera_matrix;
} push_constants;

vec3 get_translation_from_matrix(mat4 matrix)
{
	return vec3(matrix[3][0], matrix[3][1], matrix[3][2]);
}

#define FLT_MAX (1.0 / 0.0)
#define EPSILON 0.001f

struct Ray
{
	vec3 direction;
	vec3 position;
};

vec4 intersect_aabb(vec3 aabbmin, vec3 aabbmax, Ray ray)
{
	vec3 inv_dir = 1.0f / ray.direction;
	vec3 ti = (aabbmin - ray.position) * inv_dir;
	vec3 ta = (aabbmax - ray.position) * inv_dir;
	vec3 axis_min = min(ti, ta);
	vec3 axis_max = max(ti, ta);
	float tmin = max(axis_min.x, max(axis_min.y, axis_min.z));
	float tmax = min(axis_max.x, min(axis_max.y, axis_max.z));

	if (tmax >= tmin && tmin > 0.0f)
	{
		vec3 normal = -(vec3(1.0f) - step(axis_min, vec3(tmin) - EPSILON)) * sign(ray.direction);

		int axis = int(abs(normal.y) > abs(normal.x));
		if (abs(normal.z) > abs(normal[axis]))
		{
			axis = 2;
		};
		float norm = normal[axis];
		normal = vec3(0.0f);
		normal[axis] = norm;
			
		return vec4(tmin, normal);
	}
	else
	{
		return vec4(FLT_MAX, tmin, tmax, 0.0f);
	}
}

struct IntersectionState
{
	float t;
};

void intersect(inout IntersectionState state, Ray ray)
{
	vec4 t_normal = intersect_aabb(vec3(-0.5f), vec3(0.5f), ray);

	state.t = t_normal.r;
}

void main()
{
    ivec2 texelCoord = ivec2(gl_GlobalInvocationID.xy);
	ivec2 size = imageSize(image);
    uint index = texelCoord.x + texelCoord.y * size.x;

	Ray new_ray;
	new_ray.position = get_translation_from_matrix(push_constants.camera_matrix);
	new_ray.direction = ray_buffer.data[index].rgb;

	IntersectionState state;
	state.t = FLT_MAX;
	intersect(state, new_ray);

	if (state.t >= 0.0)
	{
		imageStore(image, texelCoord, vec4(state.t, state.t, state.t, 1.0f) * 0.001f);
	}
	else
	{
    	imageStore(image, texelCoord, ray_buffer.data[index]);
	}
}
